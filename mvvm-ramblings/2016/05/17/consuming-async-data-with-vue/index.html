<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Consuming async data with Vue.js | MVVM Ramblings | About data, viemodels and Vue.js</title>
  <meta name="author" content="Denis Karabaza">
  
  <meta name="description" content="Vue.js collabarator explores new techniques, develops guidelines and shares tips and tricks about Vue.js, MVVM frameworks and web development">
  
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="Consuming async data with Vue.js"/>
  <meta property="og:site_name" content="MVVM Ramblings"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/mvvm-ramblings/favicon.ico" rel="icon">
  <link rel="alternate" href="/mvvm-ramblings/atom.xml" title="MVVM Ramblings" type="application/atom+xml">
  <link rel="stylesheet" href="/mvvm-ramblings/css/style.css" media="screen" type="text/css">
</head>


<body>
<div id="page" class="site">
  <div id="primary" class="content-area">

    <header id="header" class="inner"><div class="site-branding">
  <h1 class="site-title">
    <a href="/mvvm-ramblings/">MVVM Ramblings</a>
  </h1>
  <p class="site-description">About data, viemodels and Vue.js</p>
</div>
<nav id="site-navigation" class="main-navigation" role="navigation">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
</nav></header>

    <article id="content" class="site-content">
      <main id="main" class="site-main posts-loop" role="main">
        <article class="post article">

  
  
    <h3 class="article-title"><span>Consuming async data with Vue.js</span></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/mvvm-ramblings/2016/05/17/consuming-async-data-with-vue/" rel="bookmark">
        <time class="entry-date published" datetime="2016-05-17T16:09:47.000Z">
          2016-05-17
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><p>Data in modern applications comes from asynchoronous data sources, such as AJAX requests, websockets and offline data stores. But consuming async data in MVVM world can be hard. This article aims to explain <strong>why and how to gracefully deal with async data</strong>, and to establish some practical conventions of representing async data in the viewmodel.</p>
<p>Examples are given in <a href="https://vuejs.org/" target="_blank" rel="external">Vue.js</a>, but the concept is applicable to any MVVM framework (Angular, React, etc.).</p>
<h4 id="Why-worry-at-all"><a href="#Why-worry-at-all" class="headerlink" title="Why worry at all"></a>Why worry at all</h4><p>Why do we use async data sources in the first place? I will not go into details, but the answer is <strong>blocking</strong>. Without being async, application would behave just like classic console applications, completely blocking the interface until the command is executed.</p>
<p>So how to deal with async data? The simplest aproach is to wait until all the data is ready, and only then display it. While being simple, this effectively blocks UI, rendering it unresponsive and defeating the purpose of async. Another problem is that failed data fetching might render the application unusable.</p>
<p>@TODO: demo</p>
<p>But we can do better than that, if we account for all the “phases” the data goes through:</p>
<p><img src="prep-complete-phases.svg" alt="alt text"></p>
<p>[@TODO: FMS instead of a list]</p>
<ol>
<li>Data fetching has been started and has not finished yet</li>
<li>Data fetching has finished with<br>2a. Success<br>2b. Failure</li>
</ol>
<p>And sometimes we can do even better, if the data can be loaded <strong>progressively</strong>. More on that later.</p>
<p>Now lets talk about templates. We want templates to be performant and testable. We want them to contain the minimal ammount of logic. The best way to achieve these goals is to treat templates as pure functions that accept plain data. So we need a way to <strong>represent phases of async data with plain data</strong>.</p>
<!-- #### Why having a convention

Reprasing the Pareto principle, 80% of your encounters with async data can be covered by 2-3 common patterns, so having a convention reduces cognitive load and speeds up the development process. 

The rest 20% use cases will be very hard to generalize, but using convention as a guideline will help you to come up with meaningful viewmodel representation of your UI state. -->
<h4 id="Trivial-case"><a href="#Trivial-case" class="headerlink" title="Trivial case"></a>Trivial case</h4><p>If your data fetching is fast (<a href="https://www.nngroup.com/articles/response-times-3-important-limits/" target="_blank" rel="external">under 100ms</a>) and never fails, and never returns <code>undefiend</code>, then you can use a simple pattern of representing the “no data” phase with <code>undefined</code>, and consuming it by conditionally rendering the template, or rendering two conditional branches.</p>
<p>[!@TODO: FSM with two phases]</p>
<p>Practical applications: @TODO</p>
<p>Example: @TODO</p>
<h4 id="Convention"><a href="#Convention" class="headerlink" title="Convention"></a>Convention</h4><p>To represent more then two phases we need to store some state along the value. The best way to do this is to use a “struct” pattern, where the value is wrapped into an object with additional fields, encoding the phase the value is in. All the cases below follow this pattern:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  value: &lt;Any&gt;,</span><br><span class="line">  ..., // one or more fields, representing the phase of data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The cases described bellow are not exclusive, and can be combined together.</p>
<h4 id="Use-case-Data-fetching-takes-some-time"><a href="#Use-case-Data-fetching-takes-some-time" class="headerlink" title="Use case: Data fetching takes some time"></a>Use case: Data fetching takes some time</h4><p>[!@TODO: FSM with four phases]</p>
<p>Pattern:</p>
<ul>
<li>Use the semantics of promises<ul>
<li>boolean <code>pending</code> flag</li>
<li>boolean <code>fulfilled</code> flag<ul>
<li>if <code>true</code>, then <code>value</code> is present</li>
</ul>
</li>
<li>boolean <code>rejected</code> flag<ul>
<li>if <code>true</code>, then <code>error</code> is present</li>
</ul>
</li>
</ul>
</li>
<li>Consume by having three conditional branches</li>
</ul>
<p>In case when the data fetch can not fail, this pattern can be replaced with a simpler one:</p>
<ul>
<li>Use boolean <code>pending</code> flag to represent whether the data is ready to be shown</li>
<li>Consume by having two conditional branches</li>
</ul>
<p>Practical applications: @TODO</p>
<p>Example: @TODO</p>
<h4 id="Use-case-Data-can-be-invalidated"><a href="#Use-case-Data-can-be-invalidated" class="headerlink" title="Use case: Data can be invalidated"></a>Use case: Data can be invalidated</h4><p>Pattern:</p>
<ul>
<li>Use boolean <code>invalid</code> flag</li>
</ul>
<p>Practical applications: @TODO</p>
<p>Example: @TODO</p>
<h4 id="Use-case-Data-can-be-deferred-known-to-exist-but-not-fetched-yet"><a href="#Use-case-Data-can-be-deferred-known-to-exist-but-not-fetched-yet" class="headerlink" title="Use case: Data can be deferred (known to exist, but not fetched yet)"></a>Use case: Data can be deferred (known to exist, but not fetched yet)</h4><p>Pattern:</p>
<ul>
<li>Use boolean <code>deferred</code> flag</li>
</ul>
<p>Practical applications: @TODO</p>
<p>Example: @TODO</p>
<!-- 

## Plan

+ Why worry at all
  - Argument: data is mostly asynchronous in nature
  - Argument: blocking UI until all data is loaded is bad UX
  - Argument: failed data fetch may render application unusable
  - Holy grail: lazy progressive loading of UI with prefetch

- What data sources are async
  - Callbacks (setTimeout, setInterval, setImmediate, process.nextTick, node callbacks etc.)
  - Events (UI, websockets, AJAX-polling)
  - Promises (AJAX)
  - Tasks
  - Streams
  - Observables

+ Why plain data
  - Argument: magical unwrapping of promises is bad
    - Angular deprecated it in 1.2 (proof?)
  - Pro: can represent partially incomplete values (list where some values are ready and some are not)
  - Pro: mvvm-friendly, applicable to any framework
  - Pro: testability of UI

+ Why having a convention
  - Pro: reduces cognitive load
  - Pro: helps when dealing with complicated cases

+ Common patterns
  + Simple case
    - Use `undefined` to represent "no data" phase
    - Unapplicable if data can be `undefined`
    - Unapplicable if data fetch can fail
  + Data is fetched asynchronously
    - Use { ready: <Bool>, value: <Any> }
  + Data can be fetched, then invalidated and fetched again (search results, preview, user input validation)
    - Use { ready: <Bool>, invalid: <Bool>, value: <Any> }
  + Data resembles a promise
    - Use the semantics of promises, { pending: <Bool>, fulfilled: <Bool>, rejected: <Bool>, value: <Any>, error: <Any> }
  + Data represents task (command, request)
    - Use { ready: <Bool> }
  + General case
    - { value: <Any>, <state> }

- Consuming data in the framework
  - In simple cases (flat data, trivial async state), parent cares about the state of data, and child recieves just value
  - In complicated cases (nested data) parent passes the state along the value


### Unsolved

- Dealing with two-way binding
  - You should only two-way bind data that is local to the component (or group of tightly coupled components)
- Mutable or immutable
  - If mutable, then define all state fields upfront
  - Immutable may caue issues with accidentally rewriting local state data
  - Immutable approach may be expensive
- Extra credits
  - Data is split into sections, each sections can be fetched separately
  - Reference counting from the markup
 -->

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
  

  <span class="post-tags">
    <i class="icon-tags"></i>
    <a href="/mvvm-ramblings/tags/vue/">vue</a>, <a href="/mvvm-ramblings/tags/mvvm/">mvvm</a>, <a href="/mvvm-ramblings/tags/ux/">ux</a>
  </span>


        </div>
        
    </footer>
  </div>
</article>

  



      </main>
    </article>

    <footer id="colophon" class="site-footer" role="contentinfo"><p class="site-info">
  Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
  Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
  </br>
  
  &copy; 2016 Denis Karabaza
  
</p>
</footer>
    
  </div>
</div>
</body>
</html>